{"componentChunkName":"component---src-pages-build-run-mdx","path":"/build-run/","result":{"pageContext":{"frontmatter":{"title":"Build & run the user-interface microservice","description":"Build & run the user-interface microservice"},"relativePagePath":"/build-run.mdx","titleType":"append","MdxNode":{"id":"cbbbbf75-5491-5c25-baf6-ffb884d51f74","children":[],"parent":"a55d97fe-e92d-59bf-83e8-fff481a038e4","internal":{"content":"---\ntitle: Build & run the user-interface microservice\ndescription: Build & run the user-interface microservice\n---\n\n## Pre-requisites\n\nBe sure to have cloned the root repository: `refarch_kc` as there is a dependency on the environment setting scripts (`refarch_kc/scripts/setenv.sh`).\n\nThe UI is using Angular so you need to get angular CLI installed, nodejs and npm.\n\nKeep npm up to date with the command:\n\n  ```\n  npm install -g npm\n  ```\nVerify node version (we run v 12.0)\n\n  ```\n  node -v\n  ```\n\nTo install or update Angular CLI\n\n  ```\n  cd ui\n  npm install -g @angular/cli\n  ```\n\nAnd install all the dependencies\n  ```\n  npm install\n  ```\n\nThe project was started with Angular 6 and then migrated to Angular 8 with the commands:\n  ```\n  ng update @angular/cli @angular/core\n  ng update @angular/material\n  ```\n\nThe test driven development approach is done using [mocha](https://mochajs.org/) as test runner and [chai](https://www.chaijs.com) for assertion library and Typescript. Which means those tools were installed with the command:\n```\n$ npm install mocha chai ts-node --save-dev\n# and install the supporting types for Typescript\n# npm install @types/chai @types/mocha --save-dev\n```\n\n## Build\n\n### UI Build\n\nWhile doing development, you can build the UI first, by being under the `ui` folder and run:\n\n```\nng build\n```\n\nYou should get a trace like:\n```\nchunk {main} main-es2015.js, main-es2015.js.map (main) 156 kB [initial] [rendered]\nchunk {polyfills} polyfills-es2015.js, polyfills-es2015.js.map (polyfills) 438 kB [initial] [rendered]\nchunk {runtime} runtime-es2015.js, runtime-es2015.js.map (runtime) 6.08 kB [entry] [rendered]\nchunk {styles} styles-es2015.js, styles-es2015.js.map (styles) 392 kB [initial] [rendered]\nchunk {vendor} vendor-es2015.js, vendor-es2015.js.map (vendor) 5.81 MB [initial] [rendered]\n```\n\nThe build artifacts will be stored in the `dist/` directory. Use the `--prod` flag for a production build so the javascripts will be smaller.\n\nIt is possible to test the User interface without the nodejs backend, by using\n\n```\nng serve\n```\n\nNavigate to http://localhost:4200/. The app will automatically reload if you change any of the UI source files.\n\nYou may encounter some issues as there are dependencies on the backend nodejs for some APIs and data.\n\n### UI Running unit tests\n\nRun `ng test` to execute the unit tests via [Karma](https://karma-runner.github.io).\n\n### Build and run the BFF server\n\nRun the command below:\n```\nnpm serve\n```\n\nAll those commands are executed when developing the server or ui parts. But when we need to deploy the user interface with the other components of the solution we first need to build a docker image and then be sure the other services are deployed...\n\n### Dockerize all\n\nBuild UI and server in one command: (this is what a CI/CD pipeline will use).\n\n```\n./scripts/buildDocker.sh\n```\n\nThis will build a docker image, named: `ibmcase/kcontainer-ui:latest` for local execution using docker-compose.\n\nIf you run on minikube locally use:\n\n```\n./scripts/buildDocker.sh MINIKUBE\n```\n\n## Run locally\n\nTo be able to run the UI and server locally, you need to have at least the following kafka, zookeeper, order command, order query and fleet simulator microservices up and running.\n\nAs introduced before we have two options to run the solution, Minikube or docker-compose.\n\n### Using docker compose\n\nWe recommend to read [this chapter](https://ibm-cloud-architecture.github.io/refarch-kc/deployments/local/)\n\nIf not done already start Kafka and zookeeper using the docker compose file in the root project:\n\n ```\n cd ../refarch-kc/docker\n docker-compose -f backbone-compose.yml up\n ```\n\nStart the Fleet simulator.  For the fleet simulator [see instructions here](https://github.com/ibm-cloud-architecture/refarch-kc-ms/tree/master/fleet-ms#run) to run the simulator locally.\n\nRun the following command:\n```\n./scripts/buildLocal.sh\n```\n\nStart the UI and BFF locally with `./scripts/run.sh` or with a docker `./scripts/runDocker.sh`.\n\nUse your web browser at http://localhost:31010\n\n### Using Minikube\n\nSee the instruction in [this article](https://ibm-cloud-architecture.github.io/refarch-kc/deployments/minikube/) for deploying all the components.\n\nUse the `scripts\\deployHelm MINIKUBE latest` command to use Helm to deploy the user interface release.\n\nUse your web browser at http://localhost:31010\n\n## Deploy to OpenShift Container Platform (OCP)\n\n### Deployment prerequisites\n\nRegardless of specific deployment targets (OCP, IKS, k8s), the following prerequisite Kubernetes artifacts need to be created to support the deployments of application components.  These artifacts need to be created once per unique deployment of the entire application and can be shared between application components in the same overall application deployment.\n\n1.Create `kafka-brokers` ConfigMap\n  - Command: `kubectl create configmap kafka-brokers --from-literal=brokers='<replace with comma-separated list of brokers>' -n <namespace>`\n  - Example: `kubectl create configmap kafka-brokers --from-literal=brokers='broker-3-j7fxtxtp5fs84205.kafka.svc01.us-south.eventstreams.cloud.ibm.com:9093,broker-2-j7fxtxtp5fs84205.kafka.svc01.us-south.eventstreams.cloud.ibm.com:9093,broker-1-j7fxtxtp5fs84205.kafka.svc01.us-south.eventstreams.cloud.ibm.com:9093,broker-5-j7fxtxtp5fs84205.kafka.svc01.us-south.eventstreams.cloud.ibm.com:9093,broker-0-j7fxtxtp5fs84205.kafka.svc01.us-south.eventstreams.cloud.ibm.com:9093,broker-4-j7fxtxtp5fs84205.kafka.svc01.us-south.eventstreams.cloud.ibm.com:9093' -n eda-refarch`\n\n2.Create optional `eventstreams-apikey` Secret, if you are using Event Streams as your Kafka broker provider\n  - Command: `kubectl create secret generic eventstreams-apikey --from-literal=binding='<replace with api key>' -n <namespace>`\n  - Example: `kubectl create secret generic eventstreams-apikey --from-literal=binding='z...12345...notanactualkey...67890...a' -n eda-refarch`\n\n### Deploy to OCP 3.11\n\n**Cross-component deployment prerequisites:** _(needs to be done once per unique deployment of the entire application)_\n\n1.If desired, create a non-default Service Account for usage of deploying and running the K Container reference implementation.  This will become more important in future iterations, so it's best to start small:\n  - Command: `oc create serviceaccount -n <target-namespace> kcontainer-runtime`\n  - Example: `oc create serviceaccount -n eda-refarch kcontainer-runtime`\n\n2.The target Service Account needs to be allowed to run containers as `anyuid` for the time being:\n  - Command: `oc adm policy add-scc-to-user anyuid -z <service-account-name> -n <target-namespace>`\n  - Example: `oc adm policy add-scc-to-user anyuid -z kcontainer-runtime -n eda-refarch`\n  - NOTE: This requires `cluster-admin` level privileges.\n\n**Perform the following for the `kc-ui` microservices:**\n\n1.Build and push Docker images\n\n  Create a Jenkins project, pointing to the remote GitHub repository for the KContainer UI Microservice, creating the necessary parameters.  Refer to the individual microservice's `Jenkinsfile.NoKubernetesPlugin` for appropriate parameter values.\n    - Create a String parameter named `REGISTRY` to determine a remote registry that is accessible from your cluster\n    - Create a String parameter named `REGISTRY_NAMESPACE` to describe the registry namespace to push image into\n    - Create a String parameter named `IMAGE_NAME` which should be self-expalantory\n    - Create a String parameter named `CONTEXT_DIR` to determine the correct working directory to work from inside the source code, with respect to the root of the repository\n    - Create a String parameter named `DOCKERFILE` to determine the desired Dockerfile to use to build the Docker image.  This is determined with respect to the `CONTEXT_DIR` parameter.\n    - Create a Credentials parameter named `REGISTRY_CREDENTIALS` and assign the necessary credentials to allow Jenkins to push the image to the remote repository\n\n2.Manually build the Docker image and push it to a registry that is accessible from your cluster (Docker Hub, IBM Cloud Container Registry, manually deployed Quay instance):\n    - `docker build -t <private-registry>/<image-namespace>/kcontainer-ui:latest .`\n    - `docker login <private-registry>`\n    - `docker push <private-registry>/<image-namespace>/kcontainer-ui:latest`\n\n3.Generate application YAMLs via `helm template`:\n  - Parameters:\n    - `--set image.repository=<private-registry>/<image-namespace>/<image-repository>`\n    - `--set image.tag=latest`\n    - `--set image.pullSecret=<private-registry-pullsecret>` (only required if pulling from an external private registry)\n    - `--set image.pullPolicy=Always`\n    - `--set eventstreams.env=ICP`\n    - `--set eventstreams.brokersConfigMap=<kafka brokers ConfigMap name>`\n    - `--set serviceAccountName=<service-account-name>`\n    - `--namespace <target-namespace>`\n    - `--output-dir <local-template-directory>`\n  - Example: `helm template --set image.repository=rhos-quay.internal-network.local/browncompute/kc-ui --set image.pullPolicy=Always --set eventstreams.env=ICP --set eventstreams.brokersConfigMap=kafka-brokers --set serviceAccountName=kcontainer-runtime --output-dir templ --namespace eda-refarch chart/kc-ui/`\n\n4.Deploy application using `oc apply`:\n  - `oc apply -f templ/kc-ui/templates`\n","type":"Mdx","contentDigest":"2bf0d102df3ca19f9ead60724909c788","counter":59,"owner":"gatsby-plugin-mdx"},"frontmatter":{"title":"Build & run the user-interface microservice","description":"Build & run the user-interface microservice"},"exports":{},"rawBody":"---\ntitle: Build & run the user-interface microservice\ndescription: Build & run the user-interface microservice\n---\n\n## Pre-requisites\n\nBe sure to have cloned the root repository: `refarch_kc` as there is a dependency on the environment setting scripts (`refarch_kc/scripts/setenv.sh`).\n\nThe UI is using Angular so you need to get angular CLI installed, nodejs and npm.\n\nKeep npm up to date with the command:\n\n  ```\n  npm install -g npm\n  ```\nVerify node version (we run v 12.0)\n\n  ```\n  node -v\n  ```\n\nTo install or update Angular CLI\n\n  ```\n  cd ui\n  npm install -g @angular/cli\n  ```\n\nAnd install all the dependencies\n  ```\n  npm install\n  ```\n\nThe project was started with Angular 6 and then migrated to Angular 8 with the commands:\n  ```\n  ng update @angular/cli @angular/core\n  ng update @angular/material\n  ```\n\nThe test driven development approach is done using [mocha](https://mochajs.org/) as test runner and [chai](https://www.chaijs.com) for assertion library and Typescript. Which means those tools were installed with the command:\n```\n$ npm install mocha chai ts-node --save-dev\n# and install the supporting types for Typescript\n# npm install @types/chai @types/mocha --save-dev\n```\n\n## Build\n\n### UI Build\n\nWhile doing development, you can build the UI first, by being under the `ui` folder and run:\n\n```\nng build\n```\n\nYou should get a trace like:\n```\nchunk {main} main-es2015.js, main-es2015.js.map (main) 156 kB [initial] [rendered]\nchunk {polyfills} polyfills-es2015.js, polyfills-es2015.js.map (polyfills) 438 kB [initial] [rendered]\nchunk {runtime} runtime-es2015.js, runtime-es2015.js.map (runtime) 6.08 kB [entry] [rendered]\nchunk {styles} styles-es2015.js, styles-es2015.js.map (styles) 392 kB [initial] [rendered]\nchunk {vendor} vendor-es2015.js, vendor-es2015.js.map (vendor) 5.81 MB [initial] [rendered]\n```\n\nThe build artifacts will be stored in the `dist/` directory. Use the `--prod` flag for a production build so the javascripts will be smaller.\n\nIt is possible to test the User interface without the nodejs backend, by using\n\n```\nng serve\n```\n\nNavigate to http://localhost:4200/. The app will automatically reload if you change any of the UI source files.\n\nYou may encounter some issues as there are dependencies on the backend nodejs for some APIs and data.\n\n### UI Running unit tests\n\nRun `ng test` to execute the unit tests via [Karma](https://karma-runner.github.io).\n\n### Build and run the BFF server\n\nRun the command below:\n```\nnpm serve\n```\n\nAll those commands are executed when developing the server or ui parts. But when we need to deploy the user interface with the other components of the solution we first need to build a docker image and then be sure the other services are deployed...\n\n### Dockerize all\n\nBuild UI and server in one command: (this is what a CI/CD pipeline will use).\n\n```\n./scripts/buildDocker.sh\n```\n\nThis will build a docker image, named: `ibmcase/kcontainer-ui:latest` for local execution using docker-compose.\n\nIf you run on minikube locally use:\n\n```\n./scripts/buildDocker.sh MINIKUBE\n```\n\n## Run locally\n\nTo be able to run the UI and server locally, you need to have at least the following kafka, zookeeper, order command, order query and fleet simulator microservices up and running.\n\nAs introduced before we have two options to run the solution, Minikube or docker-compose.\n\n### Using docker compose\n\nWe recommend to read [this chapter](https://ibm-cloud-architecture.github.io/refarch-kc/deployments/local/)\n\nIf not done already start Kafka and zookeeper using the docker compose file in the root project:\n\n ```\n cd ../refarch-kc/docker\n docker-compose -f backbone-compose.yml up\n ```\n\nStart the Fleet simulator.  For the fleet simulator [see instructions here](https://github.com/ibm-cloud-architecture/refarch-kc-ms/tree/master/fleet-ms#run) to run the simulator locally.\n\nRun the following command:\n```\n./scripts/buildLocal.sh\n```\n\nStart the UI and BFF locally with `./scripts/run.sh` or with a docker `./scripts/runDocker.sh`.\n\nUse your web browser at http://localhost:31010\n\n### Using Minikube\n\nSee the instruction in [this article](https://ibm-cloud-architecture.github.io/refarch-kc/deployments/minikube/) for deploying all the components.\n\nUse the `scripts\\deployHelm MINIKUBE latest` command to use Helm to deploy the user interface release.\n\nUse your web browser at http://localhost:31010\n\n## Deploy to OpenShift Container Platform (OCP)\n\n### Deployment prerequisites\n\nRegardless of specific deployment targets (OCP, IKS, k8s), the following prerequisite Kubernetes artifacts need to be created to support the deployments of application components.  These artifacts need to be created once per unique deployment of the entire application and can be shared between application components in the same overall application deployment.\n\n1.Create `kafka-brokers` ConfigMap\n  - Command: `kubectl create configmap kafka-brokers --from-literal=brokers='<replace with comma-separated list of brokers>' -n <namespace>`\n  - Example: `kubectl create configmap kafka-brokers --from-literal=brokers='broker-3-j7fxtxtp5fs84205.kafka.svc01.us-south.eventstreams.cloud.ibm.com:9093,broker-2-j7fxtxtp5fs84205.kafka.svc01.us-south.eventstreams.cloud.ibm.com:9093,broker-1-j7fxtxtp5fs84205.kafka.svc01.us-south.eventstreams.cloud.ibm.com:9093,broker-5-j7fxtxtp5fs84205.kafka.svc01.us-south.eventstreams.cloud.ibm.com:9093,broker-0-j7fxtxtp5fs84205.kafka.svc01.us-south.eventstreams.cloud.ibm.com:9093,broker-4-j7fxtxtp5fs84205.kafka.svc01.us-south.eventstreams.cloud.ibm.com:9093' -n eda-refarch`\n\n2.Create optional `eventstreams-apikey` Secret, if you are using Event Streams as your Kafka broker provider\n  - Command: `kubectl create secret generic eventstreams-apikey --from-literal=binding='<replace with api key>' -n <namespace>`\n  - Example: `kubectl create secret generic eventstreams-apikey --from-literal=binding='z...12345...notanactualkey...67890...a' -n eda-refarch`\n\n### Deploy to OCP 3.11\n\n**Cross-component deployment prerequisites:** _(needs to be done once per unique deployment of the entire application)_\n\n1.If desired, create a non-default Service Account for usage of deploying and running the K Container reference implementation.  This will become more important in future iterations, so it's best to start small:\n  - Command: `oc create serviceaccount -n <target-namespace> kcontainer-runtime`\n  - Example: `oc create serviceaccount -n eda-refarch kcontainer-runtime`\n\n2.The target Service Account needs to be allowed to run containers as `anyuid` for the time being:\n  - Command: `oc adm policy add-scc-to-user anyuid -z <service-account-name> -n <target-namespace>`\n  - Example: `oc adm policy add-scc-to-user anyuid -z kcontainer-runtime -n eda-refarch`\n  - NOTE: This requires `cluster-admin` level privileges.\n\n**Perform the following for the `kc-ui` microservices:**\n\n1.Build and push Docker images\n\n  Create a Jenkins project, pointing to the remote GitHub repository for the KContainer UI Microservice, creating the necessary parameters.  Refer to the individual microservice's `Jenkinsfile.NoKubernetesPlugin` for appropriate parameter values.\n    - Create a String parameter named `REGISTRY` to determine a remote registry that is accessible from your cluster\n    - Create a String parameter named `REGISTRY_NAMESPACE` to describe the registry namespace to push image into\n    - Create a String parameter named `IMAGE_NAME` which should be self-expalantory\n    - Create a String parameter named `CONTEXT_DIR` to determine the correct working directory to work from inside the source code, with respect to the root of the repository\n    - Create a String parameter named `DOCKERFILE` to determine the desired Dockerfile to use to build the Docker image.  This is determined with respect to the `CONTEXT_DIR` parameter.\n    - Create a Credentials parameter named `REGISTRY_CREDENTIALS` and assign the necessary credentials to allow Jenkins to push the image to the remote repository\n\n2.Manually build the Docker image and push it to a registry that is accessible from your cluster (Docker Hub, IBM Cloud Container Registry, manually deployed Quay instance):\n    - `docker build -t <private-registry>/<image-namespace>/kcontainer-ui:latest .`\n    - `docker login <private-registry>`\n    - `docker push <private-registry>/<image-namespace>/kcontainer-ui:latest`\n\n3.Generate application YAMLs via `helm template`:\n  - Parameters:\n    - `--set image.repository=<private-registry>/<image-namespace>/<image-repository>`\n    - `--set image.tag=latest`\n    - `--set image.pullSecret=<private-registry-pullsecret>` (only required if pulling from an external private registry)\n    - `--set image.pullPolicy=Always`\n    - `--set eventstreams.env=ICP`\n    - `--set eventstreams.brokersConfigMap=<kafka brokers ConfigMap name>`\n    - `--set serviceAccountName=<service-account-name>`\n    - `--namespace <target-namespace>`\n    - `--output-dir <local-template-directory>`\n  - Example: `helm template --set image.repository=rhos-quay.internal-network.local/browncompute/kc-ui --set image.pullPolicy=Always --set eventstreams.env=ICP --set eventstreams.brokersConfigMap=kafka-brokers --set serviceAccountName=kcontainer-runtime --output-dir templ --namespace eda-refarch chart/kc-ui/`\n\n4.Deploy application using `oc apply`:\n  - `oc apply -f templ/kc-ui/templates`\n","fileAbsolutePath":"/home/runner/work/refarch-kc-ui/refarch-kc-ui/docs-gatsby/src/pages/build-run.mdx"}}}}